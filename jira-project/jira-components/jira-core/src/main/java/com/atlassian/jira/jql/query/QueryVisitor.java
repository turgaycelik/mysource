package com.atlassian.jira.jql.query;

import com.atlassian.jira.jql.clause.DeMorgansVisitor;
import com.atlassian.query.clause.AndClause;
import com.atlassian.query.clause.ChangedClause;
import com.atlassian.query.clause.Clause;
import com.atlassian.query.clause.ClauseVisitor;
import com.atlassian.query.clause.NotClause;
import com.atlassian.query.clause.OrClause;
import com.atlassian.query.clause.TerminalClause;
import com.atlassian.query.clause.WasClause;
import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.Query;

import java.util.Collection;

/**
 * Used to generate the Lucene query from a {@link com.atlassian.query.Query}. This visits the nodes of the tree
 * and creates a lucene query based on its structure. Users of this class should only call {@link #createQuery} and not
 * use the visitor directly as the query in a {@link com.atlassian.jira.jql.query.QueryFactoryResult} may not be valid.
 *
 * @since v4.0
 */
class QueryVisitor implements ClauseVisitor<QueryFactoryResult>
{
    private final QueryRegistry queryRegistry;
    private final QueryCreationContext queryCreationContext;
    private final DeMorgansVisitor deMorgansVisitor;
    private final WasClauseQueryFactory wasClauseQueryFactory;
    private final ChangedClauseQueryFactory changedClauseQueryFactory;
    private boolean rootClause = true;

    ///CLOVER:OFF - used for real, does not need testing
    QueryVisitor(QueryRegistry queryRegistry, QueryCreationContext queryCreationContext,
            WasClauseQueryFactory wasClauseQueryFactory, ChangedClauseQueryFactory changedClauseQueryFactory)
    {
        this(queryRegistry, queryCreationContext, new DeMorgansVisitor(), wasClauseQueryFactory, changedClauseQueryFactory);
    }
    ///CLOVER:ON

    QueryVisitor(QueryRegistry queryRegistry, QueryCreationContext queryCreationContext, DeMorgansVisitor deMorgansVisitor,
            WasClauseQueryFactory wasClauseQueryFactory, ChangedClauseQueryFactory changedClauseQueryFactory)
    {
        this.queryRegistry = queryRegistry;
        this.queryCreationContext = queryCreationContext;
        this.deMorgansVisitor = deMorgansVisitor;
        this.wasClauseQueryFactory = wasClauseQueryFactory;
        this.changedClauseQueryFactory = changedClauseQueryFactory;
    }

    /**
     * Create a lucene query for the passed clause.
     * <p/>
     * NOTE: The query generated by this method will probably not run in Lucene even though it is correct. Lucene has
     * some quirks when dealing with negative queries. Lucene will not search for negative queries, it will only filter
     * the results from a positive query (e.g. +project:monkey -status:blocker will work while -status:blocker will
     * not).
     *
     * NOTE: This visitor will push all instances of the {@link com.atlassian.query.clause.NotClause} out of the tree
     * by using the {@link com.atlassian.jira.jql.clause.DeMorgansVisitor} so that the terminal clauses will handle
     * all the negation logic and the visitor does not need to deal with NOT's.
     *
     * @param clause the clause to process.
     * @return the generated lucene query.
     */
    public Query createQuery(final Clause clause)
    {
        // This method handles the root clause case
        this.rootClause = false;
        Clause normalisedClause = clause.accept(deMorgansVisitor);
        final QueryFactoryResult queryFactoryResult = normalisedClause.accept(this);
        return makeQuery(queryFactoryResult);
    }

    public QueryFactoryResult visit(final AndClause andClause)
    {
        if (rootClause)
        {
            return new QueryFactoryResult(createQuery(andClause));
        }

        if (andClause.getClauses().size() > BooleanQuery.getMaxClauseCount())
        {
            throw new JqlTooComplex(andClause);
        }

        BooleanQuery booleanQuery = new BooleanQuery();
        for (Clause clause : andClause.getClauses())
        {
            final QueryFactoryResult queryFactoryResult = clause.accept(this);
            if (queryFactoryResult.mustNotOccur())
            {
                booleanQuery.add(queryFactoryResult.getLuceneQuery(), BooleanClause.Occur.MUST_NOT);
            }
            else
            {
                booleanQuery.add(queryFactoryResult.getLuceneQuery(), BooleanClause.Occur.MUST);
            }
        }

        return new QueryFactoryResult(booleanQuery);
    }

    public QueryFactoryResult visit(final OrClause orClause)
    {
        if (rootClause)
        {
            return new QueryFactoryResult(createQuery(orClause));
        }

        if (orClause.getClauses().size() > BooleanQuery.getMaxClauseCount())
        {
            throw new JqlTooComplex(orClause);
        }

        BooleanQuery booleanQuery = new BooleanQuery();
        for (Clause clause : orClause.getClauses())
        {
            final QueryFactoryResult queryFactoryResult = clause.accept(this);
            booleanQuery.add(makeQuery(queryFactoryResult), BooleanClause.Occur.SHOULD);
        }

        return new QueryFactoryResult(booleanQuery);
    }

    public QueryFactoryResult visit(final NotClause notClause)
    {
        if (rootClause)
        {
            return new QueryFactoryResult(createQuery(notClause));
        }
        throw new IllegalStateException("We have removed all the NOT clauses from the query, this should never occur.");
    }

    public QueryFactoryResult visit(final TerminalClause terminalClause)
    {
        if (rootClause)
        {
            return new QueryFactoryResult(createQuery(terminalClause));
        }
        final Collection<ClauseQueryFactory> clauseQueryFactory = this.queryRegistry.getClauseQueryFactory(queryCreationContext, terminalClause);

        if (clauseQueryFactory.isEmpty())
        {
            // This time we really mean it! When we are asked to run a query for things that no longer exist we will
            // run the query the best we can, adding false to the tree for bits that we can not resolve.
            return QueryFactoryResult.createFalseResult();
        }
        try
        {
            if (clauseQueryFactory.size() == 1)
            {
                ClauseQueryFactory factory = clauseQueryFactory.iterator().next();
                return factory.getQuery(queryCreationContext, terminalClause);
            }
            else
            {
                BooleanQuery query = new BooleanQuery();
                for (ClauseQueryFactory factory : clauseQueryFactory)
                {
                    query.add(makeQuery(factory.getQuery(queryCreationContext, terminalClause)), BooleanClause.Occur.SHOULD);
                }
                return new QueryFactoryResult(query);
            }
        }
        catch (BooleanQuery.TooManyClauses tooManyClauses)
        {
            throw new JqlTooComplex(terminalClause);
        }
        // This could happen for Factories that use their own QueryVisitors, e.g. SavedFilterCQF
        catch (JqlTooComplex jqlTooComplex)
        {
            throw new JqlTooComplex(terminalClause);
        }
    }

    @Override
    public QueryFactoryResult visit(WasClause clause)
    {
        return wasClauseQueryFactory.create(queryCreationContext.getUser(), clause);
    }

    @Override
    public QueryFactoryResult visit(ChangedClause clause)
    {
        return changedClauseQueryFactory.create(queryCreationContext.getUser(), clause);
    }

    private static Query makeQuery(final QueryFactoryResult queryFactoryResult)
    {
        if (queryFactoryResult.mustNotOccur())
        {
            //we must wrap the thing in a boolean query so that the "mustNot" in the result is represented.
            final BooleanQuery query = new BooleanQuery();
            query.add(queryFactoryResult.getLuceneQuery(), BooleanClause.Occur.MUST_NOT);
            return query;
        }
        else
        {
            return queryFactoryResult.getLuceneQuery();
        }
    }

     /**
     * This exception is thrown when the JQL Query is to complex to be generated into an Lucene Query.
     * It is caught in {@link com.atlassian.jira.jql.query.LuceneQueryBuilder} and converted into a {@link com.atlassian.jira.issue.search.ClauseTooComplexSearchException}.
     */
    static class JqlTooComplex extends RuntimeException
    {
        private final Clause clause;

        JqlTooComplex(Clause clause)
        {
            this.clause = clause;
        }

        public Clause getClause()
        {
            return clause;
        }
    }
}
